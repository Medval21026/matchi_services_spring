# ================================
# === Configuration Production ===
# ================================

# === Base de données MySQL (Railway) ===
# Railway fournit automatiquement ces variables quand MySQL est lié au service
# Support de plusieurs variantes de noms de variables pour compatibilité

# URL de connexion - Support de plusieurs formats Railway
spring.datasource.url=jdbc:mysql://${MYSQLHOST:${MYSQL_HOST:localhost}}:${MYSQLPORT:${MYSQL_PORT:3306}}/${MYSQLDATABASE:${MYSQL_DATABASE:railway}}?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&rewriteBatchedStatements=true
spring.datasource.username=${MYSQLUSER:${MYSQL_USER:root}}
spring.datasource.password=${MYSQLPASSWORD:${MYSQL_PASSWORD:}}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# === Pool de connexions (HikariCP) ===
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.leak-detection-threshold=60000

# === Hibernate / JPA ===
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=false
# Le dialect MySQL est auto-détecté, inutile de le forcer (warning dans les logs)
# spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
spring.jpa.properties.hibernate.jdbc.time_zone=UTC
# Désactiver cette option qui peut causer des problèmes de transaction avec HikariCP
# spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true

# === Gestion des transactions ===
# Configuration pour éviter les erreurs "Unable to commit against JDBC Connection"
spring.jpa.properties.hibernate.connection.handling_mode=delayed_acquisition_and_release_after_transaction
spring.transaction.default-timeout=30
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=false

# === Swagger / Springdoc ===
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
# Forcer HTTPS dans les URLs Swagger
springdoc.swagger-ui.use-root-path=true

# === Thymeleaf (si utilisé) ===
spring.thymeleaf.enabled=true
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html

# === Logging ===
logging.level.root=INFO
logging.level.com.matchi=INFO
logging.level.com.matchi.config.DatabaseConfig=DEBUG
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=WARN
logging.level.org.springframework.web=INFO
logging.level.org.springframework.security=INFO
logging.level.org.springframework.jdbc=DEBUG
logging.level.com.zaxxer.hikari=DEBUG

# === Configuration Serveur ===
server.port=${PORT:8080}
server.address=0.0.0.0

# === Configuration Proxy (Railway) ===
# Railway utilise un reverse proxy qui ajoute des headers X-Forwarded-*
# Spring Boot doit faire confiance à ces headers pour détecter HTTPS
server.forward-headers-strategy=framework
server.use-forward-headers=true

# === Encodage HTTP ===
spring.http.encoding.charset=UTF-8
spring.http.encoding.enabled=true
spring.http.encoding.force=true
